#!/bin/bash

set -euo pipefail
shopt -s nullglob

LC_ALL="C"
LANG="C"
LANGUAGE="C"

show_help() {
    cat << EOF
Usage:
        $(basename "$0") [-o|--options] <source dir>

        Build proxmox package.
        
        If <source dir> is not supplied, the current folder will be used.

Options:
        -h                  Show this help.
        -u|--update-config  Update config file with the latest release version.
        -n|--native-build   Build without docker.
        -l|--local-docker   Build local docker image first.
        -i|--inplace        Build without touching .src folder.
EOF
}

ARGV=("$@")
TEMP="$(getopt -o "hunil" -l "help,update-config,native-build,inplace,local-docker" -n "$0" -- "$@")"
if (( $? != 0 ))
then
    show_help
    exit
fi
eval set -- "$TEMP"

env_init() {
    UPDATE_CONFIG="false"
    NATIVE_BUILD="false"
    INPLACE_BUILD="false"
    DOCKER_REGISTRY="ghcr.io/protondi/"
}

env_init

while true
do
    TEMP="$1"
    shift
    case "$TEMP" in
        -h|--help)
            show_help
            exit
            ;;
        -u|--update-config)
            UPDATE_CONFIG="true"
            ;;
        -n|--native-build)
            NATIVE_BUILD="true"
            ;;
        -i|--inplace)
            INPLACE_BUILD="true"
            ;;
        -l|--local-docker)
            DOCKER_REGISTRY=""
            ;;
        --)
            break
            ;;
        *)
            echo "Unrecognized option '$TEMP'." >&2
            exit 1
            ;;
    esac
done

SCRIPT_DIR="$(dirname "$(realpath "$0")")"
WORK_DIR="$(realpath "${1:-$PWD}")"

if ! $NATIVE_BUILD
then
    DOCKER_IMAGE="$(docker image ls -qf=reference=${DOCKER_REGISTRY}proxmox-make-action:main)"

    if [[ -z $DOCKER_REGISTRY ]]
    then
        docker build --force-rm -t "${DOCKER_REGISTRY}proxmox-make-action:main" "$SCRIPT_DIR/docker"
    else
        docker pull ${DOCKER_REGISTRY}proxmox-make-action:main
    fi

    if [[ $DOCKER_IMAGE != "$(docker image ls -qf=reference=${DOCKER_REGISTRY}proxmox-make-action:main)" ]]
    then
        docker image rm ${DOCKER_REGISTRY}proxmox-make-action:builder &>/dev/null || true
    fi

    DOCKER_BUILDER="$(docker image ls -qf=reference=${DOCKER_REGISTRY}proxmox-make-action:builder)"
    if [[ -z $DOCKER_BUILDER ]]
    then
        docker tag ${DOCKER_REGISTRY}proxmox-make-action:main ${DOCKER_REGISTRY}proxmox-make-action:builder
    fi

    DOCKER_OPTIONS=( "--name" "proxmox-make-action" )
    DOCKER_OPTIONS+=( "--workdir" "$PWD" )
    DOCKER_OPTIONS+=( "--mount" "type=bind,source=$PWD,destination=$PWD" )
    if [[ "$PWD" != "$SCRIPT_DIR" ]]
    then
        DOCKER_OPTIONS+=( "--mount" "type=bind,source=$SCRIPT_DIR,destination=$SCRIPT_DIR" )
    fi
    if [[ "$PWD" != "$WORK_DIR" ]]
    then
        DOCKER_OPTIONS+=( "--mount" "type=bind,source=$WORK_DIR,destination=$WORK_DIR" )
    fi
    docker container rm proxmox-make-action &>/dev/null || true
    docker run "${DOCKER_OPTIONS[@]}" ${DOCKER_REGISTRY}proxmox-make-action:builder bash -c "sed -i -E \"s/^(runner):(x?):([0-9]+):([0-9]+):(.*):(.*):(.*)$/\1:\2:$(id -u):$(id -g):\5:\6:\7/\" /etc/passwd && sudo -u runner \"$0\" --native-build ${ARGV[*]}"
    docker commit proxmox-make-action ${DOCKER_REGISTRY}proxmox-make-action:builder
    docker container rm proxmox-make-action
    exit
fi

if $INPLACE_BUILD
then
    pushd "$WORK_DIR/.src"
else
    pushd "$WORK_DIR"

    if ! git remote | grep -q "upstream"
    then
        git remote add upstream "git://git.proxmox.com/git/$(basename "$(git remote get-url origin)")"
    fi

    git fetch upstream

    git switch -C upstream upstream/master
    git push -u origin
    git switch main

    if [[ ! -d "$WORK_DIR/.src" ]]
    then
        git submodule add -f -b upstream "$(git remote get-url origin)" .src
        PACKAGE_COMMIT=""
    else
        PACKAGE_COMMIT="$(git submodule status .src | awk '{print $1}')"
    fi

    popd
    pushd "$WORK_DIR/.src"

    if [[ -n $(git status -s) ]]
    then
        git reset --hard origin/upstream
        git clean -ffd
    fi
    git fetch
    git checkout origin/upstream

    LAST_RELEASE="$(git log --pretty=oneline -n 1 --grep 'bump version to')"
    if ! egrep -q "^[0-9a-f]{40} bump version to .+$" <<< "$LAST_RELEASE"
    then
        echo "Malformed commit message. Got '$LAST_RELEASE'." >&2
        exit 1
    fi

    read COMMIT i1 i2 i3 VERSION <<< "$LAST_RELEASE"
    if [[ "$PACKAGE_COMMIT" == "$COMMIT" ]]
    then
        echo "Current release is already the latest." >&2
        exit
    fi

    git checkout $COMMIT
    patches=($WORK_DIR/*.patch)
    if (( ${#patches[@]} != 0))
    then
        if [[ -z $(git config user.name) ]]
        then
            git config user.name "github-actions[bot]"
            git config user.email "41898282+github-actions[bot]@users.noreply.github.com"
        fi
        git am --reject --whitespace=fix "${patches[@]}"
    fi
fi

sudo apt-get update
sudo apt-get full-upgrade --no-install-recommends -y
if [[ -f "./debian/control.in" ]]
then
    make all deb &>/dev/null || true
    sudo apt-get build-dep --no-install-recommends -y ./build
    make distclean
else
    sudo apt-get build-dep --no-install-recommends -y .
fi
sudo rm -rf /var/lib/apt/lists/*
make all deb

popd

rm -rf "$WORK_DIR/.output"
mkdir -p "$WORK_DIR/.output"
cp $WORK_DIR/.src/*.deb "$WORK_DIR/.output"

pushd "$WORK_DIR/.src"

git checkout $COMMIT

popd
